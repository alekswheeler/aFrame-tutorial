<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<script src="https://aframe.io/releases/1.6.0/aframe.min.js" defer></script>
	<script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js" defer></script>
	
	<!-- gesture detector: https://github.com/fcor/arjs-gestures -->
	<script src="https://raw.githack.com/fcor/arjs-gestures/master/dist/gestures.js"></script>

</head>
<body style="margin : 0px; overflow: hidden;">
	<div id="debug"
     style="
       position: fixed;
       bottom: 10px;
       left: 10px;
       padding: 6px 10px;
       background: rgba(0,0,0,0.6);
       color: #0f0;
       font-size: 12px;
       border-radius: 6px;
       z-index: 9999;
       pointer-events: none;
     ">
  		debug: idle
	</div>

	<a-scene
	  	arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
  		embedded
  		renderer="logarithmicDepthBuffer: true;"
  		id="scene"
		gesture-detector
		>
		<a-marker type="pattern" url="./card.patt">
			<a-entity 
				position="0 0 0"
				gltf-model="../assets/rounded-dice/Dice_BSwap.gltf"
				id="jug"
				gesture-handler
				>
			</a-entity>
		</a-marker>
		<a-entity camera></a-entity>
	</a-scene>
		<script>
		var el = document.getElementById("jug");
		var sceneEl = document.getElementById("scene");
		var isMarkerVisible = false;
		
		//rotation
		let isRotating = false;
		let startX = 0;
		let startY = 0;
		let startRotation = null;
		let targetEl = null;
		var rotationFactor = 0.4;

		sceneEl.addEventListener("markerFound", (e) => {
			//debug("found");
			isMarkerVisible = true;
		});

		sceneEl.addEventListener("markerLost", (e) => {
			//debug("lost");
			isMarkerVisible = false;
		});

		function debug(msg) {
  			document.getElementById('debug').innerText = msg;
		}

		sceneEl.addEventListener('touchstart', onTouchStart, { passive: false });
  		sceneEl.addEventListener('touchmove', onTouchMove, { passive: false });
  		sceneEl.addEventListener('touchend', onTouchEnd);

		// this.addEventListener('touchstart', (evt) => {
		// 	if (evt.touches.length === 2) {
		// 		debug("two fingers on screen");
		// 	}
		// });

		function resetRotation(evt) {
			el.object3D.rotation.x = 0;
		}

		function onTouchStart(evt) {
			if (evt.touches.length !== 1) return;

			evt.preventDefault();

			isRotating = true;

			startX = evt.touches[0].clientX;
			startY = evt.touches[0].clientY;

			// pega o entity que vocÃª quer rotacionar
			targetEl = document.getElementById("jug");

			startRotation = targetEl.object3D.rotation.clone();
		}

		function onTouchMove(evt) {
			if (!isRotating || evt.touches.length !== 1) return;

			evt.preventDefault();

			const dx = evt.touches[0].clientX - startX;
			const dy = evt.touches[0].clientY - startY;

			const speed = 0.010;

			// Y = arrasto horizontal
			targetEl.object3D.rotation.y =
				startRotation.y + dx * speed;

			// X = arrasto vertical
			targetEl.object3D.rotation.x =
				startRotation.x + dy * speed;

			// opcional: limitar pitch
			// targetEl.object3D.rotation.x = THREE.MathUtils.clamp(
			// 	targetEl.object3D.rotation.x,
			// 	-Math.PI / 2,
			// 	Math.PI / 2
			// );

			debug(`rot dx:${dx.toFixed(1)} dy:${dy.toFixed(1)}`);
		}

		function onTouchEnd(evt) {
			if (evt.touches.length === 0) {
				isRotating = false;
				targetEl = null;
			}
		}
	</script>
</body>
</html>